# 运行时数据区 Run Data Area

## HotSpot

程序计数器

本地方法栈

虚拟机栈

堆空间（新生代、老年代）

非堆空间  （方法区）

## 线程

一个程序里的运行单元，允许一个应用有多个线程并行执行。

## 程序计数器（PC寄存器）

### PC Registers 

### 作用：

​	用来存储指向下一条指令的地址。

### 介绍：

​	很小的一块内存空间，几乎可以忽略不计。也很快。

### 问题

**使用Pc寄存器存储字节吗指令地址作用是什么？**

**为什么使用Pc寄存器记录当前线程的执行地址呢？**

​	CPU在不停的切换线程，切换回来之后，需要知道该从哪里开始执行。

​	JVM的字节码解释器需要通过改变PC寄存器的值 来明确下一条应该执行什么样的字节码指令。

**PC寄存器为什么被设定为线程私有的？**

<u>（并行 并发）</u>

串行：一条执行

并行：同时的执行

并发：依次执行，切换执行





## 虚拟机栈（JVM Stacks）

栈（stack）：运行时的单位。

堆（heap）：存储的单位。

**Java虚拟机栈是什么？**

每一个线程在创建的时候，都会创建一个虚拟机栈。内部保存一个个的栈帧（Stack Frame）。

生命周期和线程一致。

作用：主管方法的运行，保存方法的局部变量部分结果，并参与放的的调用和返回。 

[线程是私有的]

[一个栈帧对应一个java的方法]

[一次次的方法调用就对应着入栈出栈] 

​	方法执行，伴随着入栈；

​	执行结束后，出栈工作。

[栈不存在垃圾回收问题]

**虚拟机栈可能出现的问题：**

​	如果栈的大小是固定的，可能出现StackOverflowError。

​	如果虚拟机栈可以动态扩展，并在扩展的时候不能申请到足够多的内存，或者创建新线程的时候，没有足够内存去创建对应的虚拟机栈，会抛出OutOfMemoryError。

**设置虚拟机栈大小：**

-Xss

### 栈的存储单位

每个线程都有自己的栈，栈中的数据都以栈帧格式存在。

在这个线程上正在执行的每个方法都各自对应一个栈帧。

**栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息**。

正在运行的栈帧 -> 当前栈帧 -> 当前方法 ->当前类

#### 局部变量表



#### 操作数栈（Operand Stack）

先进后出（FILO）

主要用于：保存计算过程的中间结果，同时作为计算过程中变量临时存储空间。

操作数栈，不是采用访问索引的方式来进行数据访问（尽管使用数组实现的）

