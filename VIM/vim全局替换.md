# 全局替换

主要使用两个ex命令：

1. g（global，全局）
2. s（sbustitute，替换）

## 基本替换

| 动作                             | 命令               |
| -------------------------------- | ------------------ |
| 将当前行第一个出现的old改为new   | :s/old/new/        |
| 将这一行中每一个old替换为new     | :s/old/new/g       |
| 将50-100行之间每一个old替换为new | :50,100s/old/new/g |
| 同下（1,\$s=%s）                 | :1,$s/old/new/g    |
| 将整个文件每一行old替换为new     | :%s/old/new/g      |

## 确认替换

- 我们常常会在替换发生之后，发现替换结果有误，需要撤销。

1. 通过u，撤销上一次替换。
2. 替换之前通过 :w 写入文件，需要替换时，使用:q!不保存退出。
3. 也可以使用 :e! 读出上一个版本的缓冲区内容。（即撤销到上个版本）



- **除此之外，vim编辑器提供了一种<u>确认替换---c选项（confirm）</u>**

| 动作           | 命令           |
| -------------- | -------------- |
| 在替换之前询问 | :%s/old/new/gc |

此时，如果存在多个替换选项，编辑器会逐个询问

1. y，代表本次替换
2. n，代表本次不替换
3. a，替换符合的所有
4. q，退出（不替换）
5. l，替换本次并退出



- 一个技巧

  使用n（重复上一次搜索）、点号（.）（重复上一次命令）结合进行局部替换。

  | 命令      | 行为             |
  | --------- | ---------------- |
  | /old      | 搜索old          |
  | cwnew+ESC | 替换old为new     |
  | n         | 重复搜索         |
  | .         | 重复命令（替换） |

  注意：

  ​	遇到不需要替换的old，直接按n跳到下一个搜索结果即可。

  ​	cwnew：表示c、w、new，修改、一个单词、单词拼写new

## 上下文相关的替换

解释：找到包含模式的某一行时，对另外一个字符串进行替换。

| 命令                   | 行为                                                         |
| ---------------------- | ------------------------------------------------------------ |
| :g/pattern/s/old/new/g | （第一个g）对文件所有行起作用，在出现pattern的行发生替换，将old替换称为new，将这一行所有old都替换（最后一个g） |

注意：

​	第一个g，表示对所有行都起作用。

​	最后一个g，表示在行中进行全局替换。（没有这个g，只替换匹配行中的第一个）



| 命令               | 行为                                                         |
| ------------------ | ------------------------------------------------------------ |
| :g/string/s//new/g | 包含string的行中，相同的字符串string做替换。(全部string都替换) |
| :%s/string/new/g   | 与上一句作用相同（意义相同）                                 |

## 模式匹配规则

### 搜索模式中的元字符

- .(点号)

匹配出任何单一字符（换行符除外），空格也是字符。

p.p可以匹配出pep、pip或者pep等。

- *(星号)

匹配出位于此符号前的单一字符，该单一字符出现0次到多次。

bugs**s**\*可以匹配出bugs（\*之前到**s**出现0次）、bugss（\*之前到**s**出现一次）、bugsss（\*之前到**s**出现2次）等。

- ^

用于正则表达式的开头，它后面的正则表达式必须位于一行的开头。当不是用在正则表达式的开头时，^就表示其本意。

^java只会匹配出位于一行开头的java，而^...只会匹配出一行的前三个字符。

- $

用于正则表达式的结尾，他前面的正则表达式必须位于一行的结尾。当不是用于正则表达式的结尾时，$就表示其本意。

- \

转义字符，将其后面的特殊字符当作一般字符。

例如，\\.可以匹配出实际的英文句号；\\*可以匹配出实际的\*号。

- [ ]

匹配出方括号里面的任意一个字符。

如果匹配目标是一个范围的字符，则可以使用第一个字符加上连接符（-），再加最后一个字符来表示。

插入符号（^）只有位于方括号的第一个位置才有特殊意义，表示匹配任何不在方括号中的字符。

方括号中大部分元字符都会被当作一般字符，但是有三个仍然需要转义：\\、-、]。

例如，[ABCF]ber可以匹配出Aber、Bber、Cber、Fber。

例如，[a-z]匹配出任何a到z之间的小写字母；[0-9]会匹配出任何0到9之间的数字。

例如，\[^a-z\]，表示匹配任何不是小写字母的字符。

- \\( \\)

会将\\(与 \\)之间的模式保存到特殊的空间。（称为保留缓存区）。这种方法可以保存任意一行中的9个模式。

例如：

​	\\(hadoop\\) or \\(spark\\)

会将hadoop保存到缓冲区1，而将spark保存到缓冲区2。这种保留模式可以在之后使用 \\1到\\9的序列重新显示。

我们可以使用：

:%s/\\(hadoop\\) or \\(spark\\) /\2 or \1/

将hadoop or spark 改成 spark or hadoop

也可以在搜索替换字符串的时候使用\n表示法，例如

:s/\\(abcd\\)\1/Hadoop-spark/

可以将abcdabcd改成Hadoop-spark。

- \\< \\>

会匹配出任何以某些字符开头(\\<)或结尾(\\>)的单词。注意：单词的结尾与开头是由标点与空格来分隔的。

例如，\\<ac只会匹配出ac开头的单词；ac\\>只会匹配出以ac结尾的单词。特闷都不回匹配出react这种ac在中间的单词。

- ~

会匹配出任何上一次搜索时候使用的正则表达式。

注意：只能用在正则搜索中，而不能用在正则替换中。

例如，上一次正则搜索了The，我们可以使用/~n来搜索Then。
